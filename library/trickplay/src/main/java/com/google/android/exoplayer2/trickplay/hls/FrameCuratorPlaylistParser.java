package com.google.android.exoplayer2.trickplay.hls;

import android.net.Uri;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParserFactory;
import com.google.android.exoplayer2.upstream.ParsingLoadable;
import com.google.android.exoplayer2.util.Log;

/**
 * Parses Dual Mode iFrame only media playlists.
 *
 * DualMode playlists are generated by the {@link AugmentedPlaylistParser} by generating additional
 * iFrame only playlists from a source playlist, adding a URL fragment as a marker to the source
 * playlist URL.  The source playlist is loaded and curated as indicated by the fragment value.
 *
 * This parser is created for each load of a playlist, start of load constructs this parser
 * and the completion of load calls the {@link #parse(Uri, InputStream)} method.  So no state is
 * kept in this object required passed the call to parse.
 */
public class FrameCuratorPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
    private static final String TAG = "FrameCuratedPlaylistParser";

    private final ParsingLoadable.Parser<HlsPlaylist> parserDelegate;
    private final Map<Uri, HlsMediaPlaylist> previousSourcePlaylists;
    @Nullable private final HlsMasterPlaylist masterPlaylist;
    @Nullable private final HlsMediaPlaylist previousCuratedMediaPlaylist;
    @Nullable private final FrameRateAnalyzer frameRateAnalyzer;

    enum PlaylistUpdateAction {
        NOTHING,
        UPDATE,
        CREATE
    }

    public FrameCuratorPlaylistParser(HlsPlaylistParserFactory hlsPlaylistParserFactory,
        @Nullable FrameRateAnalyzer rateAnalyzer,
        @NonNull HlsMasterPlaylist hlsMasterPlaylist,
        Map<Uri, HlsMediaPlaylist> lastLoadedSourcePlayists,
        @Nullable HlsMediaPlaylist previousHlsMediaPlaylist) {
        parserDelegate = hlsPlaylistParserFactory.createPlaylistParser(hlsMasterPlaylist, previousHlsMediaPlaylist);
        previousSourcePlaylists = lastLoadedSourcePlayists;
        frameRateAnalyzer = rateAnalyzer;
        masterPlaylist = hlsMasterPlaylist;
        previousCuratedMediaPlaylist = previousHlsMediaPlaylist;
    }

    @VisibleForTesting
    FrameCuratorPlaylistParser() {
        parserDelegate = new DefaultHlsPlaylistParserFactory().createPlaylistParser();
        previousSourcePlaylists = new HashMap<>();
        frameRateAnalyzer = null;
        masterPlaylist = null;
        previousCuratedMediaPlaylist = null;
    }

    @VisibleForTesting
    @Nullable
    HlsMediaPlaylist getSourceMediaPlaylist(@NonNull Uri uri) {
        return previousSourcePlaylists.get(uri);
    }

    @NonNull
    @Override
    public HlsPlaylist parse(@NonNull Uri uri, @NonNull InputStream inputStream) throws IOException {
        HlsPlaylist playlist = parserDelegate.parse(uri, inputStream);
        if (playlist instanceof HlsMediaPlaylist && uri.getFragment() != null) {
            int subsetTarget = Integer.parseInt(uri.getFragment());
            HlsMediaPlaylist currentSourcePlaylist = (HlsMediaPlaylist) playlist;
            HlsMediaPlaylist previousSource = previousSourcePlaylists.get(uri);

            // 0 - do nothing, 1 - update playlist, 2 - generate new playlist
            PlaylistUpdateAction playlistAction = PlaylistUpdateAction.CREATE;

            if (previousSource != null && previousCuratedMediaPlaylist != null) {
                if (!currentSourcePlaylist.isNewerThan(previousSource)) {
                    playlistAction = PlaylistUpdateAction.NOTHING;
                } else if (currentSourcePlaylist.isUpdateValid(previousSource)) {
                    playlistAction = PlaylistUpdateAction.UPDATE;
                }
            }

            SmallestIFramesCurator smallestIFramesCurator;

            switch (playlistAction) {
                case NOTHING:
                    playlist = previousCuratedMediaPlaylist;
                    break;
                case UPDATE:
                    smallestIFramesCurator = new SmallestIFramesCurator(previousCuratedMediaPlaylist);
                    playlist = (HlsPlaylist) smallestIFramesCurator.updateCurrentCurated(currentSourcePlaylist, previousSource, subsetTarget);
                    previousSourcePlaylists.put(uri, currentSourcePlaylist);
                    break;
                case CREATE:
                    smallestIFramesCurator = new SmallestIFramesCurator();
                    playlist = (HlsPlaylist) smallestIFramesCurator.generateCuratedPlaylist(currentSourcePlaylist, subsetTarget, uri);
                    previousSourcePlaylists.put(uri, currentSourcePlaylist);
                    break;
            }

        }

        if (playlist instanceof HlsMediaPlaylist && frameRateAnalyzer != null && playlist != previousCuratedMediaPlaylist ) {
            assert masterPlaylist != null;      // true because of constructor path
            HlsMediaPlaylist updatedMediaPlaylist = (HlsMediaPlaylist) playlist;
            if (updatedMediaPlaylist.isUpdateValid(previousCuratedMediaPlaylist)) {
                frameRateAnalyzer.playlistUpdated(masterPlaylist, updatedMediaPlaylist);
            } else if (updatedMediaPlaylist.isNewerThan(previousCuratedMediaPlaylist)) {
                Log.w(TAG, "ignoring invalid playlist for frame rate analyze.");
            }
        }
        return playlist;
    }
}