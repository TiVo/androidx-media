package com.google.android.exoplayer2.trickplay.hls;

import android.net.Uri;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParserFactory;
import com.google.android.exoplayer2.upstream.ParsingLoadable;
import com.google.android.exoplayer2.util.Log;

/**
 * Parses Dual Mode iFrame only media playlists.
 *
 * DualMode playlists are generated by the {@link AugmentedPlaylistParser} by generating additional
 * iFrame only playlists from a source playlist, adding a URL fragment as a marker to the source
 * playlist URL.  The source playlist is loaded and curated as indicated by the fragment value.
 *
 * This parser is created for each load of a playlist, start of load constructs this parser
 * and the completion of load calls the {@link #parse(Uri, InputStream)} method.  So no state is
 * kept in this object required passed the call to parse.
 */
public class FrameCuratorPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
    private static final String TAG = "FrameCuratedPlaylistParser";

    private final ParsingLoadable.Parser<HlsPlaylist> parserDelegate;
    private final Map<Uri, HlsMediaPlaylist> previousSourcePlaylists;
    @Nullable private final HlsMasterPlaylist masterPlaylist;
    @Nullable private final HlsMediaPlaylist previousCuratedMediaPlaylist;
    @Nullable private final FrameRateAnalyzer frameRateAnalyzer;

    public FrameCuratorPlaylistParser(HlsPlaylistParserFactory hlsPlaylistParserFactory,
        @Nullable FrameRateAnalyzer rateAnalyzer,
        @NonNull HlsMasterPlaylist hlsMasterPlaylist,
        Map<Uri, HlsMediaPlaylist> lastLoadedSourcePlayists,
        @Nullable HlsMediaPlaylist previousHlsMediaPlaylist) {
        parserDelegate = hlsPlaylistParserFactory.createPlaylistParser(hlsMasterPlaylist, previousHlsMediaPlaylist);
        previousSourcePlaylists = lastLoadedSourcePlayists;
        frameRateAnalyzer = rateAnalyzer;
        masterPlaylist = hlsMasterPlaylist;
        previousCuratedMediaPlaylist = previousHlsMediaPlaylist;
    }

    @VisibleForTesting
    FrameCuratorPlaylistParser() {
        parserDelegate = new DefaultHlsPlaylistParserFactory().createPlaylistParser();
        previousSourcePlaylists = new HashMap<>();
        frameRateAnalyzer = null;
        masterPlaylist = null;
        previousCuratedMediaPlaylist = null;
    }

    @VisibleForTesting
    @Nullable
    HlsMediaPlaylist getSourceMediaPlaylist(@NonNull Uri uri) {
        return previousSourcePlaylists.get(uri);
    }

    @NonNull
    @Override
    public HlsPlaylist parse(@NonNull Uri uri, @NonNull InputStream inputStream) throws IOException {
        HlsPlaylist playlist = parserDelegate.parse(uri, inputStream);
        if (playlist instanceof HlsMediaPlaylist && uri.getFragment() != null) {
            int subsetTarget = Integer.parseInt(uri.getFragment());
            HlsMediaPlaylist currentSourcePlaylist = (HlsMediaPlaylist) playlist;
            HlsMediaPlaylist previousSource = previousSourcePlaylists.get(uri);
            HlsMediaPlaylist curatedPlaylist;
            if (canUsePreviousPlaylist(currentSourcePlaylist, previousSource, previousCuratedMediaPlaylist)) {
                SmallestIFramesCurator smallestIFramesCurator = new SmallestIFramesCurator(previousCuratedMediaPlaylist);
                curatedPlaylist = smallestIFramesCurator.updateCurrentCurated(currentSourcePlaylist, previousSource, subsetTarget);
            } else {
                SmallestIFramesCurator smallestIFramesCurator = new SmallestIFramesCurator();
                curatedPlaylist = smallestIFramesCurator.generateCuratedPlaylist(currentSourcePlaylist, subsetTarget, uri);
            }

            previousSourcePlaylists.put(uri, currentSourcePlaylist);
            playlist = curatedPlaylist;
        }
        if (playlist instanceof HlsMediaPlaylist && frameRateAnalyzer != null) {
            assert masterPlaylist != null;      // true because of constructor path
            HlsMediaPlaylist updatedMediaPlaylist = (HlsMediaPlaylist) playlist;
            if (updatedMediaPlaylist.isUpdateValid(previousCuratedMediaPlaylist)) {
                frameRateAnalyzer.playlistUpdated(masterPlaylist, updatedMediaPlaylist);
            } else if (updatedMediaPlaylist.isNewerThan(previousCuratedMediaPlaylist)) {
                Log.w(TAG, "ignoring invalid playlist for frame rate analyze.");
            }
        }
        return playlist;
    }

    private boolean canUsePreviousPlaylist(
        @NonNull HlsMediaPlaylist currentSourcePlaylist,
        @Nullable  HlsMediaPlaylist previousSource,
        @Nullable HlsMediaPlaylist previousCuratedMediaPlaylist) {
        boolean canUse = previousCuratedMediaPlaylist != null && previousSource != null;
        if (canUse) {
            canUse = currentSourcePlaylist.isUpdateValid(previousSource);
        }
        return canUse;
    }

}