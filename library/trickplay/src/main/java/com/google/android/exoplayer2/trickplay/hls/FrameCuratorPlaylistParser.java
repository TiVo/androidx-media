package com.google.android.exoplayer2.trickplay.hls;

import android.net.Uri;
import android.util.Pair;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.android.exoplayer2.source.hls.playlist.DefaultHlsPlaylistParserFactory;
import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParserFactory;
import com.google.android.exoplayer2.upstream.ParsingLoadable;
import com.google.android.exoplayer2.util.Log;

/**
 * Parses Dual Mode iFrame only media playlists.
 *
 * DualMode playlists are generated by the {@link AugmentedPlaylistParser} by generating additional
 * iFrame only playlists from a source playlist, adding a URL fragment as a marker to the source
 * playlist URL.  The source playlist is loaded and curated as indicated by the fragment value.
 *
 * This parser is created for each load of a playlist, start of load constructs this parser
 * and the completion of load calls the {@link #parse(Uri, InputStream)} method.  So no state is
 * kept in this object required passed the call to parse.
 */
public class FrameCuratorPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
    private static final String TAG = "FrameCuratedPlaylistParser";

    private final ParsingLoadable.Parser<HlsPlaylist> parserDelegate;
    private final Map<Uri, HlsMediaPlaylist> previousSourcePlaylists;
    @Nullable private final HlsMasterPlaylist masterPlaylist;
    @Nullable private final HlsMediaPlaylist previousMediaPlaylist;
    @Nullable private final FrameRateAnalyzer frameRateAnalyzer;

    public FrameCuratorPlaylistParser(HlsPlaylistParserFactory hlsPlaylistParserFactory,
        @Nullable FrameRateAnalyzer rateAnalyzer,
        @NonNull HlsMasterPlaylist hlsMasterPlaylist,
        Map<Uri, HlsMediaPlaylist> lastLoadedSourcePlayists,
        @Nullable HlsMediaPlaylist previousHlsMediaPlaylist) {
        parserDelegate = hlsPlaylistParserFactory.createPlaylistParser(hlsMasterPlaylist, previousHlsMediaPlaylist);
        previousSourcePlaylists = lastLoadedSourcePlayists;
        frameRateAnalyzer = rateAnalyzer;
        masterPlaylist = hlsMasterPlaylist;
        previousMediaPlaylist = previousHlsMediaPlaylist;
    }

    @VisibleForTesting
    FrameCuratorPlaylistParser() {
        parserDelegate = new DefaultHlsPlaylistParserFactory().createPlaylistParser();
        previousSourcePlaylists = new HashMap<>();
        frameRateAnalyzer = null;
        masterPlaylist = null;
        previousMediaPlaylist = null;
    }

    @VisibleForTesting
    @Nullable
    HlsMediaPlaylist getSourceMediaPlaylist(@NonNull Uri uri) {
        return previousSourcePlaylists.get(uri);
    }

    @NonNull
    @Override
    public HlsPlaylist parse(@NonNull Uri uri, @NonNull InputStream inputStream) throws IOException {
        HlsPlaylist playlist = parserDelegate.parse(uri, inputStream);
        if (playlist instanceof HlsMediaPlaylist && uri.getFragment() != null) {
            int subsetTarget = Integer.parseInt(uri.getFragment());
            HlsMediaPlaylist sourcePlaylist = (HlsMediaPlaylist) playlist;

            HlsMediaPlaylist curatedPlaylist;
            if (previousMediaPlaylist == null) {
                SmallestIFramesCurator smallestIFramesCurator = new SmallestIFramesCurator();
                curatedPlaylist = smallestIFramesCurator.generateCuratedPlaylist(sourcePlaylist, subsetTarget, uri);
            } else {
                SmallestIFramesCurator smallestIFramesCurator = new SmallestIFramesCurator(previousMediaPlaylist);
                HlsMediaPlaylist previousSource = previousSourcePlaylists.get(uri);
                curatedPlaylist = smallestIFramesCurator.updateCurrentCurated(sourcePlaylist, previousSource, subsetTarget);
            }

            previousSourcePlaylists.put(uri, sourcePlaylist);
            playlist = curatedPlaylist;
        }
        if (playlist instanceof HlsMediaPlaylist && frameRateAnalyzer != null) {
            assert masterPlaylist != null;      // true because of constructor path
            HlsMediaPlaylist updatedMediaPlaylist = (HlsMediaPlaylist) playlist;
            if (updatedMediaPlaylist.isUpdateValid(previousMediaPlaylist)) {
                frameRateAnalyzer.playlistUpdated(masterPlaylist, updatedMediaPlaylist);
            } else if (updatedMediaPlaylist.isNewerThan(previousMediaPlaylist)) {
                Log.w(TAG, "ignoring invalid playlist for frame rate analyze.");
            }
        }
        return playlist;
    }

    static Pair<List<HlsMediaPlaylist.Segment>, List<HlsMediaPlaylist.Segment>> computeSegmentsDelta(
        HlsMediaPlaylist updated, HlsMediaPlaylist previous) {
        List<HlsMediaPlaylist.Segment> removed = new ArrayList<>();
        List<HlsMediaPlaylist.Segment> added = new ArrayList<>();
        if (updated.isUpdateValid(previous)) {
            int mediaSequenceDelta = (int) (updated.mediaSequence - previous.mediaSequence);
            removed.addAll(previous.segments.subList(0, mediaSequenceDelta));

            int firstAdded = updated.segments.size() - mediaSequenceDelta;
            added.addAll(updated.segments.subList(firstAdded, updated.segments.size()));
        } else {
            Log.w(TAG, "Warning, update is not valid so ignoring");
        }
        return new Pair<>(removed, added);
    }
}