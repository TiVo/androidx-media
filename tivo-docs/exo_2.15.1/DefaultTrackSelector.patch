diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index efe9078e42..3ffdfcab82 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -17,6 +17,7 @@ package com.google.android.exoplayer2.trackselection;
 
 import android.content.Context;
 import android.graphics.Point;
+import android.os.Build;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.text.TextUtils;
@@ -1722,10 +1723,10 @@ public class DefaultTrackSelector extends MappingTrackSelector {
       int minVideoHeight,
       int minVideoFrameRate,
       int minVideoBitrate) {
-    if ((format.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {
-      // Ignore trick-play tracks for now.
-      return false;
-    }
+//    if ((format.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {
+//      // Ignore trick-play tracks for now.
+//      return false;
+//    }
     return isSupported(formatSupport, /* allowExceedsCapabilities= */ false)
         && ((formatSupport & requiredAdaptiveSupport) != 0)
         && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
@@ -1757,10 +1758,10 @@ public class DefaultTrackSelector extends MappingTrackSelector {
       @Capabilities int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         Format format = trackGroup.getFormat(trackIndex);
-        if ((format.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {
-          // Ignore trick-play tracks for now.
-          continue;
-        }
+//        if ((format.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {
+//          // Ignore trick-play tracks for now.
+//          continue;
+//        }
         if (isSupported(
             trackFormatSupport[trackIndex], params.exceedRendererCapabilitiesIfNecessary)) {
           VideoTrackScore trackScore =
@@ -2015,10 +2016,65 @@ public class DefaultTrackSelector extends MappingTrackSelector {
 
   // Utility methods.
 
+  /**
+   * Compare two device "." or "-" separated version numbers to see which is later.
+   * WARNING TiVo specific Utility methods not integrated in core ExoPlayer.
+   *
+   * @return 0 if versions are equal, -1 if version2 is later and 1 if version1 is later.
+   */
+  private static int compareVersions(String version1, String version2) {
+    String[] string1Vals = version1.split("\\.|-");
+    String[] string2Vals = version2.split("\\.|-");
+    int length = Math.max(string1Vals.length, string2Vals.length);
+    for (int i = 0; i < length; i++) {
+      try {
+        Integer v1 = 0;
+        Integer v2 = 0;
+        v1 = (i < string1Vals.length) ? Integer.parseInt(string1Vals[i]) : 0;
+        v2 = (i < string2Vals.length) ? Integer.parseInt(string2Vals[i]) : 0;
+        //Making sure Version1 bigger than version2
+        if (v1 > v2) {
+          return 1;
+        }
+        //Making sure Version1 smaller than version2
+        else if (v1 < v2) {
+          return -1;
+        }
+      } catch (NumberFormatException n) {
+        // ... Do nothing.
+      }
+    }
+    //Both are equal
+    return 0;
+  }
+
+  /**
+   * Returns true if the device firmware is known to support visual trick play in tunneling mode.
+   * WARNING TiVo specific Utility methods not integrated in core ExoPlayer.
+   *
+   * @return Whether the device supports tunneling VTP.
+   */
+  private static boolean platformSupportsTunnelingTrickPlay() {
+    return ((Build.MANUFACTURER.equals("Technicolor") &&
+                    // Jade 21
+                    (Build.DEVICE.equals("jade21") ||
+                    // Ruby Millicom
+                    (Build.DEVICE.equals("uiw4059mil") && compareVersions(Build.VERSION.INCREMENTAL, "1.1-220218") >= 0) ||
+                    // Jade Millicom
+                    (Build.DEVICE.equals("uiw4054mil") && compareVersions(Build.VERSION.INCREMENTAL, "9.0-220225") >= 0) ||
+                    // Jade Hotwire
+                    (Build.DEVICE.equals("uiw4054hwc") && compareVersions(Build.VERSION.INCREMENTAL, "5.3.1") >= 0))) ||
+            (Build.MANUFACTURER.equals("ARRIS") &&
+                    // Comscope VIP6102W
+                    (Build.DEVICE.equals("vip6102w") && compareVersions(Build.VERSION.INCREMENTAL, "10.01.04.03.36") >= 0)));
+  }
+
+
   /**
    * Determines whether tunneling can be enabled, replacing {@link RendererConfiguration}s in {@code
    * rendererConfigurations} with configurations that enable tunneling on the appropriate renderers
    * if so.
+   * WARNING contains TiVo specific modifications not integrated in core ExoPlayer.
    *
    * @param mappedTrackInfo Mapped track information.
    * @param renderererFormatSupports The {@link Capabilities} for each mapped track, indexed by
@@ -2036,6 +2092,7 @@ public class DefaultTrackSelector extends MappingTrackSelector {
     // one video renderer to support tunneling and have a selection.
     int tunnelingAudioRendererIndex = -1;
     int tunnelingVideoRendererIndex = -1;
+    boolean videoOnly = true;
     boolean enableTunneling = true;
     for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
       int rendererType = mappedTrackInfo.getRendererType(i);
@@ -2060,13 +2117,22 @@ public class DefaultTrackSelector extends MappingTrackSelector {
             }
           }
         }
+        if (rendererType == C.TRACK_TYPE_AUDIO) {
+          videoOnly = false;
+        }
       }
     }
-    enableTunneling &= tunnelingAudioRendererIndex != -1 && tunnelingVideoRendererIndex != -1;
+
+    // Enable tunneling if request and supported on audio and video OR if the platform supports
+    // VTP in tunneling mode and the it's supported by the video decoder.
+    enableTunneling &= (tunnelingAudioRendererIndex != -1 && tunnelingVideoRendererIndex != -1) ||
+            (tunnelingVideoRendererIndex != -1 && videoOnly && platformSupportsTunnelingTrickPlay());
     if (enableTunneling) {
       RendererConfiguration tunnelingRendererConfiguration =
           new RendererConfiguration(/* tunneling= */ true);
-      rendererConfigurations[tunnelingAudioRendererIndex] = tunnelingRendererConfiguration;
+      if (tunnelingAudioRendererIndex != -1) {
+        rendererConfigurations[tunnelingAudioRendererIndex] = tunnelingRendererConfiguration;
+      }
       rendererConfigurations[tunnelingVideoRendererIndex] = tunnelingRendererConfiguration;
     }
   }
