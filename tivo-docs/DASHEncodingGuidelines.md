## Summary

A DASH-encoded presentation is essentially quite simple:

1. A manifest, consisting of a *Media Presentation Descriptor* (MPD) and it's child elements, which describes the content and how it can be accessed.
2. Data containers that clients will download over the course of a presentation in order to obtain media samples.

The Media Presentation Descriptor (MPD) contains one or more `Period` elements, each `Period` contains one or more `AdaptationSet` elements, which contain one or more `Representation` elements that either contain `Segment` elements or imply segments by use of a `SegmentTemplate`

This document will outline specific DASH implementation requirements to support the main Xperi players, Shaka and ExoPlayer.  Everything in the document is taken from the specifications in the References section, but from the point of view of the actual player implementations.

## Timing Model

This section provides an overview with links to the respective specs and guidelines for what Xperi has determined produces a DASH Timing Model that is compliant with the players we support.  Xperi recommends following the more restrictive [DASH-IOP Restricted Timing Model](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html).  Later in the Streaming Features section we outline how to achieve advanced content requirements within this model.

The DASH ISO Standard ([ISO / IEC 23009 Spec](https://www.iso.org/standard/79329.html), *Section 3.2.7 DASH Timing Model*) allows for many options for mapping time in the client (player) to timestamps in the samples, enabling these functions in the client:

1. **Sample TImeline Mapping** &mdash; map a *media segment* within a `Representation` from a seek position
2. **Availability Window Management** &mdash; resolve segment availability for live playback

### Sample Timeline Mapping

#### MPD Time

The DASH-IOP introduces an [MPD timeline](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#mpd-timeline) and describes how to map it to the [sample timeline](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#sample-timeline) in order to achieve the first function.   

The *MPD timeline* is mapped to wall-clock time by the `MPD@availabilityStartTime` attribute, which simply maps zero on the *MPD timeline* to wall-clock time (for live operation).  Wall-clock on the client is synchronized with the origin server using the schema in the `UTCTiming` element. MPD Time to wall-clock time is only done for live playback by simply adding the `MPD@availabilityStartTime`

For ExoPlayer MPD Time is kept internally as a tuple of the current `Period` (both playing and loading) and `periodPositionUs` which is microseconds relative to the current `Period`.  In ExoPlayer, periods map directly to a DASH *Period*.  So ExoPlayer *position* maps to the [MPD timeline](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#mpd-timeline) quite simply as:

```java
  MPD Time = Period@start + periodPosition
```

ExoPlayer exposes Playback Position on the UI as an offset into the current [Window](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.Window.html).  When ExoPlayer processes a seek to a Playback Position it simply takes this offset into the `Window` and converts it to a `periodPosition`

In Dash.js player, MPD Time is called `presentationTime`.  As you can see in the [TimelineConverter.js](https://github.com/Dash-Industry-Forum/dash.js/blob/0982920ec72e061b88a09b80762488b2c2c7845c/src/dash/utils/TimelineConverter.js#L128), this is resolved to the Period before resolving to Sample Time (in Dash.js, Sample Time is called `mediaTime`).  Playback Position is simply MPD Time set to the `<video>` tag.

#### Sample Time

Sample time is time on the [sample timeline](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-sampletimeline), quite simply this is time as generated by the encoders.  In ExoPlayer this is called `sampleTime` and in Dash.js it is `mediaTime`.  

The `@presentationTimeOffset` is the key to mapping MPD Time to Sample Time, it is described in the ISO standard, *Section 5.3.9 Segments and Segment information* (Table 15) and in the DASH-IOP in the [sample timeline](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-sampletimeline) section.  

Quite simply:

```java
periodPosition = (sampleTime - @presentationTimeOffset) / @timescale
```

 Where `@presentationTimeOffset` and `@timescale` are from the **Represenation** presenting the sample

**Note well** `@presentationTimeOffset` and `@timescale` are in the context of a **Representation**.   They are defined in *SegmentBaseType* (MPD Schema) and may be inherited from any level up to and including the **Period**.

The DASH-IOP section [5.3 Segment addressing modes](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#addressing) is relatively clear and absolutely correct in how the `S@t` (Explicit addressing) and correspondingly the `(segmentIndex - S@startNumber) * S@duration)` are in *Sample time* and map directly to the **SegmentTemplate**  variables *$Time$* and *$Number$*.   The ISO 230009 standards are less clear, in *Table 20 Identifiers for URL templates* calls it the "MPD start time",  [DASH-IF Issue #36](https://github.com/Dash-Industry-Forum/MPEG/issues/36#issuecomment-1503834456) references this confusion.

The `S@t` attribute is the `$Time$` value and also the `sidx.earliest_presentation_time` in the Segment's MPEG container.

For ExoPlayer all loaded samples are converted to periodPosition as they are queued to the [SampleQueue](https://github.com/google/ExoPlayer/blob/2c4a567c74088c639d699eeefe139c38e254e230/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java#L556) which simply buffers samples on their way to the decoder (`MediaCodec` API).  

To resolve a seek to a `periodPosition` to the matching segment containing a sample for the position, ExoPlayer performs the mapping to segment by locating the [segment reference](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#segment-references) (in the active *Representation*) for which the MPD Time falls within it's [segment start point](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#segment-start-point) to *segment end point* (start + duration). 

For Dash.js, Shaka, and likely all other browser (Media Source Extension) based players this value is passed to the Media Source directly, the browser players set [SourceBuffer.timestampOffset](https://www.w3.org/TR/media-source-2/#dom-sourcebuffer-timestampoffset) from the `@presentationTimeOffset` value to nomalize the time bar displayed time.

### Live Operation

It is critical to synchronize the clocks of the client with the clock of origin when using a [dynamic MPD](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#dynamic-mpd).  The IOP Restricted Timing Model requires a `UTCTiming` element.  ExoPlayer falls back to using NTP but Shaka **does not**, unless the Shaka configuration specifies a backup time sync source.  NTP Is not required, the DASH-IF IOP states:

> The time indicated by the [wall clock](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#wall-clock) does not necessarily need to match some universal standard as long as the DASH client and service are mutually synchronized.

Xperi recommends using an explicit **UTCTiming** element with one of the following methods:

1.  `direct` schema &mdash; encoding the time in the *@value* attribute as described in ISO 23009-1 section 5.8.5.7 DASH UTC Timing Schemes, essentially ISO-8601 extended format.  This method avoids an extra network request to a time server, however the MPD request must not be cached in the Edge servers
2. `http-iso` or `http-xsdate` schema &mdash;  With this method a separate URL that is never cached returns the date in the respective format

Note, none of the Xperi-supported players use the **LeapSecondInformation** element so this can be ignored. 

The two critical functions of the player for live operation are:

1. Availability Window Management &mdash; determine start and end wall clock time for the available segments for playback
2. MPD Refreshes &mdash; conditions that cause the player to validate the MPD

#### Availability Window Management

The players must continually manage the "Live Window" (ExoPlayer expresses this as [Timeline.Window](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.Window.html), positions internally in ExoPlayer are always ***Period*** relative, and ExoPlayer maps DASH *Period* directly to the [Timeline.Period](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.Period.html) object).   

The bounds of ExoPlayer's *Window* are exactly the DASH [availiblity window](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#availability-window) cropped by the containing [Period](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-period).  The ExoPlayer Period contains all the child **AdaptationSets** and their **Representations** 

A number of boundary conditions on how the **Period** crops the child **Representations** as explained exhaustively in the DASH-IF IOP [Section 5.2.4 Representations](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-representation), most of this is supported by the players with the following restrictions:

1. *@eptDelta* &mdash; attribute is not supported by ExoPlayer

ExoPlayer determines the Availability window base on the addressing mode

* *Explicit addressing* &mdash; using the startTime of the first or last segments, across the **AdaptationSet**[s] - presentationTimeOffset

* *Simple addressing* &mdash;using synchromized time and the *MPD@timeShiftBufferDepth*

##### With Explicit Addressing

ExoPlayer manages the window from **Representations**,  the calculation assumes the restrictions in the IOP section [5.2.4. Representations](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-representation).

For ExoPlayer available start time (in Sample Timeline time) is calculated as:

```java
firstPeriod = mpd.periods(0);
availableStartTime = firstPeriod.startTime
for (AdaptationSet adaptationSet : firstPeriod.adaptationSets) {
  SegmentBase base = adaptationSet.representations[0].index
  if (base != null && base.getAvailableSegmentCount(periodDurationUs, nowUnixTimeUs) > 0) {
    availableStartTime = max(availableStartTime, base.getFirstAvailableSegmentTime())
  }
}
```

For available end time, logic is similar but (i) using min() in place of max(), and (ii) using getLastAvaliableSegmentTime() + lastAvailableSegmentDuration()).  Note well this implies that availability is cut to the smallest ranged **AdaptationSet**

##### With Implicit Addressing

As segment times are not directly specified the players use the *MPD@timeShiftBufferDepth* and time synchronized by the **UTCTiming** element (`nowUnitTime`)
* first available segment time = `nowUnixTime` - *MPD@timeShiftBufferDepth*
* last available segment time = `nowUnixTime` + *TotalAvailabilityTimeOffset*


#### MPD Refreshes

This is covered pretty completely in the DASH-IF IOP, [Section 5.2.9.6. MPD refreshes](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-mpd-refreshes).   ExoPlayer does a timer-based refresh every *MPD@minimumUpdatePeriod*.   For Low Latency, ExoPlayer also supports in-band *emsg* box events when MPD is 0, the origin must then signal as specified in DASH-IF IOP, [Section 6.7. Update signaling via in-band events](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#inband) 

ExoPlayer will refresh the MPD to obtain more segments (*Explicit addressing*) or make more segments [available](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#available) (*Simple addressing*) by extending the validity duration.

#### Live Startup

For each MPD update the player recalculate the Availablity Window and, for ExoPlayer, the target live offset.  The initial load also calculates a starting position for the initial seek

##### Live Offset

Following the initial MPD load, the players determine live offset parameters.   For ExoPlayer, there are three values:

1. Minimum Live Offset
2. Maximum Live Offset
3. Target Live Offset

The specific data sources for these, in priority order, are:

1. User-specified value
2. Value in *MPD/ServiceDescription* element (See ISO Spec, Annex K)

Failing a value a specific data source

- max live offset = beginning of the availability window
- min live offset = (now - end of the window) + *MPD@minBufferTime*
- target live offset = either MPD@suggestedPresentationDelay or fallback target live offset value (30 seconds for ExoPlayer)

If the resulting target live offset is > max live offset, then it is set to min(5, windowDuration / 2), with the result further constraint to be between min and max live offset

##### Start Position

Live playback starts a default position, this is calculated as follows:

```java
defaultPosition = max((now - targetLiveOffset), 5, (windowDuration / 2))
```



## Segment Addressing Modes

The ISO 23009-1 standard expresses very concisely the different options for the three elements used to define segments, basically, the default values can be set with an element as high as the **Period** element level to allow for a compact MPD.  to quote the standard (*5.3.9 Segments and Segment information*)

> The elements **SegmentBase**, **SegmentTemplate** and **SegmentList** may be present in the **Representation** element itself. In addition, to express default values, they may be present in the **Period** and **AdaptationSet** elements. At each level at most one of the three, **SegmentBase**, **SegmentTemplate**, and **SegmentList**, shall be present. Further, if **SegmentTemplate** or **SegmentList** is present on one level of the hierarchy, then the other one shall not be present on any lower hierarchy level.
>
> **SegmentBase**, **SegmentTemplate**, and **SegmentList** shall inherit attributes and elements from the same element on a higher level. If the same attribute or element is present on both levels, the one on the lower level shall take precedence over the one on the higher level.

The **SegmentList**, basically like HLS segments, is described in ISO standard section 5.3.9.3, while supported by ExoPlayer it is not very flexible, textually verbose, and not included in the DASH-IF IOP it will not be mentioned further.

The addressing modes are described in the DASH-IF IOP,  [5.3. Segment addressing modes](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#addressing)

1. *Explicit addressing* &mdash; aka SegmentTemplate w/SegmentTimeline, defined in the ISO 23009-1 section *5.3.9.4 Segment template* and described in DASH-IF IOP [5.3.3 Explicit addressing](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#addressing-explicit) This is the recommended method for *dynamic* (Live) MPD.
2. *Indexed addressing* &mdash; aka SegmentBase, defined in ISO 23009-1 section *5.3.9.2 Segment base information* and DASH-IF IOP [5.3.1. Indexed addressing](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#addressing-indexed).  This mode is useful for On Demand (VOD) by allowing a very compact manifest.
3. *Simple addressing* &mdash; aka SegmentTemplate, defined in ISO 23009-1 section *5.3.9.4 Segment template*.  With this method, if there are multiple segments they must all be the same duration (except the last in the period can be shorter). The segment URL is derived from time based on its position.   This method requires:
   * All segments are all the same duration
   * The first segment reference must start at the **Period** start time

Some constraints of note from the DASH-IF IOP are:

1. All Representations in the same AdaptationSet SHALL use the same addressing mode. (mixing addressing modes across AdaptationSets is allowed)
2. Any mode other than the aforementioned three addressing modes SHALL NOT be used

Other suggestions:

1. Code the SegmentTemplate/SegmentTimeline at the AdaptationSet level to avoid redundancy.

The easiest way to understand Segment Addressing from the player's perspective is how each mode produces what the ISO 23009-1 standard refers to as *Segment Information* (section 5.3.9.5 Segment information), or what the player needs for each segment:

* *Segment URLs* &mdash; HTTP URL (plus byte range if applicable) to fetch the media segment itself and supporting information if needed (Initialization, Index, and Bitstream Switching Segment)
* *Availability* &mdash; Availability start and end time (for *dynamic* MPD)
* *Segment MPD Time* &mdash; Start time (MPD Timeline) and duration of the segment

This information must be available from all three addressing modes, it is most exact with *Explicit addressing*.

### Explicit addressing (SegmentTimeline)

If the *SegmentTemplate* (the multi-segment base type) does not contain an *@duration* attribute then a SegmentTimeline must be used to produce *Segment Information*.   The *SegmentTemplate* should be at the *AdaptationSet* level if it is common to the representations (this is usually true for transcoded video).

The *Segment Information* is produced as follows:

* *Segment URLs* &mdash;  From the templates subtituting either the *$Number$* or *$Time$*, see ISO 23009-1 section *5.3.9.4.4 Template-based Segment URL construction*.  Note, placing the SegmentTemplate at the AdaptationSet level requires adding the *$RepresentationID$* variable to the template
* *Availability* &mdash; Availability start and end time (for *dynamic* MPD)
* *Segment MPD Time* &mdash; Start time (MPD Timeline) and duration of the segment

### Index addressing (SegmentBase)

This mode is useful for *static* presentations or any other case where a single CMAF file per track can be generated with an *Index segment* (CMAF file with a single `sidx` (Segment Index Box)).  The representation contains a **BaseURL** element with the CMAF track file reference and the **SegmentBase** element contains the byte ranges for the initialization segment and *index segment*.

ExoPlayer considers this an "explicit" addressing mode.  This mode can be used in a *dynamic* presentation, but it is only useful for alternate content to report a gap in a live stream (following an early terminated period).   Do not mix with other adressing modes in the same period.

### Simple Addressing (SegmentTemplate w/o SegmentTimeline)

This is described very well in the DASH-IOP [Simple addressing](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#addressing-simple) section.  Without the **SegmentTimeline** element the players must infer the set of available Segments in the representation.   This is done by considering the MPD timeline boundaries established from containing **Period** from one of the following constraints:

1. Explicit duration of the **Period**
2. Duration established by any other Explicit addressing mode **AdaptationSet** in the **Period**
3. *static* mode **MPD** duration
4. [availability Window](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-availability) (*now* time and the  *MPD@timeShiftBufferDepth* )

Note the last constraint, *availability Window* requires the origin to continuously produce segments that are available at *SegmentTemplate@duration* intervals or the player will get 404 errors.   This is not entirely bad, as the Xperi-supported players all will retry on 404 error quietly.   Using this addressing mode can allow the player to fetch the newest live segments without requiring an MPD refresh.



## Elements and Attributes

The descriptions in this section are sourced from the ISO/IEC 23009-1:2019 4th Edition and the [DASH IF IOP v4.3](https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf)

### MPD

The MPD is the root element of the DASH document (aka "manifest").  The table below lists the schema-mandated attributes and their use by the Xperi-supported players.

| Attribute Name             | Description                                                  |
| -------------------------- | ------------------------------------------------------------ |
| @profiles                  | Ignore by the players, but this recommendation expects the origin adheres <br />to `http://dashif.org/guidelines/dash-if-simple` and live (dynamic) a are assumed to follow ISO Base media file format live profile (`urn:mpeg:dash:profile:isoff-live:2011`) |
| @type                      | *static* or *dynamic* for VOD vs live respectively.  Not schema required, default is *static* |
| @availabilityStartTime     | Required for *dynamic*.  This is the anchor for the *MPD Timeline* (see the Timing Model section above). <br />Note for *dynamic* this value *does not change* across updates (See Section 8.4 ISO Base media file format live profile in ISO/IEC 23009-1:2019 |
| @publishTime               | Required for *dynamic*, this indicates the wall-clock time the MPD was published by the origin. |
| @mediaPresentationDuration | Required for *static* unless the duration can be calculated by the duration of the `Period` elements in the presentation. |
| @minBufferTime             | Schema required, The DASH-IOP [Minimum buffer time signaling](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#minbuffertime-feature)  gives a long description of this with lots left to interpretation.  [Shaka Player](https://github.com/shaka-project/shaka-player/issues/2000) and [ExoPlayer](https://github.com/google/ExoPlayer/issues/819#issuecomment-1175022549) take two different views on how this feature should be implemented.  Xperi's position is that this feature should be used as ExoPlayer does, based on *ISO/IEC 2009-1 5.3.4.1 Relation of Bandwidth and Minimum Buffer Time attributes* the value sets a lower bound on the live edge offset target. |
| @timeShiftBufferDepth| This is used for *dynamic* only when the addressing mode is not explicit. The value is optional (if not specified it is assumed to be infinite).  This sets the *Availability window*, that is the time period in wall-clock time during which segments are available.  See the *Live Operation* section for details. |
| @suggestedPresentationDelay | This is used for *dynamic* only. Optional, if specified this sets ExoPlayer's Target Live Offset, see [Live Streaming](https://exoplayer.dev/live-streaming.html).  For Shaka Player it directly sets the start time for live playback, see Shaka Player's DASH Manifests [Live Edge](https://github.com/shaka-project/shaka-player/blob/main/docs/design/dash-manifests.md#live-edge) section.  For ExoPlayer see the *Live Startup* section for details on how playback start position and live edge management uses DASH metadata.  Xperi recommends using this value to indicate delays in the origin server pipeline otherwise the player will excessively buffer by choosing a live edge that is too aggressive. |
| @minimumUpdatePeriod | Only needed for *dynamic*. If not specified it indicates the MPD does not change (only possible for *Simple addressing*).   The clients all use this as the maximum time between fetches of the MPD, see the Live Operation section above. |

Attributes not in the above table **are not used** by the supported players.

The players only require at least one `Period` element as a child of the `MPD` element.  These optional elements are parsed and treated as defined in the table below:

| MPD Child Element | Description                                                  |
| ----------------- | ------------------------------------------------------------ |
| ServiceDescriptor | This is used for latency, as described in ISO/IEC 2009-1 Annex K, ExoPlayer implements this as described in [Low-latency live streaming with ExoPlayer](https://medium.com/google-exoplayer/low-latency-live-streaming-with-exoplayer-8552d5841060) |
| Location          | ExoPlayer supports this and follows the recommendation in DASH-IF-IOP 4.3, section 3.2.15.3.  If there are multiple `Location` elements ExoPlayer ignores all but the last.  Shaka processes all `Location` elements. |
| UTCTiming         | The schemas `direct`,  `http-iso`,  `http-xsdate`,  `ntp` are supported by ExoPlayer.  Shaka player supports all but `ntp`.   Both support either the 2012 and 2014 versions.  In the absence of a `UTCTiming` element, ExoPlayer uses the `time.android.com` NTP server. Shaka player **does not** support a default for this, you must specify a [clockSyncUri](https://github.com/shaka-project/shaka-player/blob/main/docs/tutorials/faq.md) <br /><br />Clock sync is critcal for DASH live operation, Xperi recommends specifying |
| Period            | At least one period is required, multiple periods must be used to encapsulate changes to the presentation that require player intervention, including, changes in AdpatationSets, media  timestamp changes, etc. |
| BaseURL           | Set the base URL[s] for resolving all child element relative URI  references |

### BaseURL

The semantics of this element are described in great detail in the ISO standard section *5.6 Base URL Processing*, at every level from **MPD** down to **Representation** element.

| Attribute Name          | Description                                                  |
| ----------------------- | ------------------------------------------------------------ |
| @availabilityTimeOffset | Optional, default is INF.  Specifies an offset to define the adjusted segment availability time.  The value from the first BaseURL from each level, the calculated `TotalAvailabilityTimeOffset` is the sum from all values from the Representation level up, see section [5.2.9.2. Availability](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-availability) in the DASH-IOP for details. |
| @serviceLocation        | This attribute specifies a relationship between BaseURL's at different levels.  For example, if there are multiple CDN networks.   The BaseURL value is resolved to an absolute URL at the Representation parse level (recursively resolved).  The version of ExoPlayer Xperi supports has fallback support that utilizes multiple BaseURL's and this feature, see the Medium article, [ExoPlayer 2.15 - What's New](https://medium.com/google-exoplayer/exoplayer-2-15-whats-new-4239c693ea8e).  It has also been in Shaka player for quite a while, [Use multiple BaseURLs for failover #68](https://github.com/shaka-project/shaka-player/issues/68) |
| @priority               | This is defined in the DVB DASH Extensions and can be used to determine a sort for multiple BaseURL's.   See the [DVB ESTI Technical Spec](https://www.etsi.org/deliver/etsi_ts/103200_103299/103285/01.02.01_60/ts_103285v010201p.pdf#page=67) for details.  Basically, priority determines the sort order. |
| @weight                 | The weight describes the relative weighting of BaseURLs with the same priority, with the semantics that a BaseURL with a weight of 2 is twice as likely to be chosen by a Player as one with a weight of 1.   ExoPlayer uses a simple random selection over the total weight at a priority. |

Anything from the ISO IEC 23009-1 Section *5.6 Base URL Processing* not in the table is not supported by the Xperi players

### Period

The DASH-IOP defines a DASH Period as:

> An [MPD](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#mpd) defines an ordered list of one or more consecutive non-overlapping periods ([[DASH\]](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#biblio-dash) 5.3.2). A [period](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#periods) is both a time span on the [MPD timeline](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#mpd-timeline) and a definition of the data to be presented during this time span. [Period](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#periods) timing is relative to the zero point of the [MPD timeline](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#mpd-timeline), though often indirectly (being relative to the previous [period](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#periods)).

For ExoPlayer the Period concept is exposed abstractly for all sources of playback (DASH, SS, HLS, Progressive media),  The ExoPlayer [Timeline](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.html) docs explain how playback time is mapped to time in a Period.

DASH Periods are useful for merging content, possibly from completely different sources, into a single presentation.  Specific use cases are:

* Changes in set of *Representations* (dropping or adding an audio track)
* Gaps in live content
* Ad insertion
* Timestamp discontinuities in the transcoded output

Notes:

1. Few players support gaps in the MPD timeline (Period @start  is greater than previous Period@start + @duration)
2. All players Xperi truncate samples to the bounds of the period.
3. Overlapping segment for Period connectivity is supported by all the Xperi-supported players, see [12.1. Segment reference duplication during connected period transitions](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#connectivity-duplicates).  This is useful, for ad insertion mid-segment.
4. All players support Early Termination Periods, which is a period that is shortened.  Period can be shortened (i) implicitly, by adding a following period, (ii) or explicitly by modifying *Period@duration*). 
5. Modifying the `Period@start` is not allowed or *Period@id* 

The semantics of the **Period** are described in the ISO 23009 standard section *5.3.2 Period*.  The attributes in the table below are just the subset that is allowed by the Xperi-supported players.

| Attribute Name | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| @id            | Optional, except for *dynamic* manifest.  In a *dynamic* manifest this attribute must be specified and immutable.   The ISO standard recommends using UUIDs. |
| @start         | Optional, in which case it is inferred as (i) default 0 if first Period and *static*, (ii) inferred as previous `Period@duration + Period@start`, (iii) else see *5.3.2 Period* for "Early Available Periods", this is not supported by any player in the set Xperi supports. |
| @duration      | Optional, if not specified it is inferred from (i) the following Period's @start, (ii) the duration of the presentation, *static* only |

### SegmentBase

The **SegmentBase** element itself defines a single segment for [indexed addressing](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#indexed-addressing) as well as specifies the base attributes for the **SegmentTemplate**, **SegmentList** and elements, that is these elements extend Segment Base in the schema.  This is the source for *Segment Information*

The base attributes common to all three are listed below.  Anything from the ISO IEC 23009-1 *Section 5.3.9.2.2 Segment Base* not in the table is not supported by the Xperi players


| Attribute Name          | Description                                                  |
| ----------------------- | ------------------------------------------------------------ |
| @timescale              | Optional, but a default value of 1 is hardly ever useful.  The units per second for all real-time durations and offsets in the *Segment Information* |
| @presentationTimeOffset | Offset between Segment Information time values and MPD Timeline, this is the offset (if any) between [MPD Timeline](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#mpd-general-timeline) and [Sample Timeline](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-sampletimeline) in *@timescale* units.  If not specified it is assumed to be 0, that is sample times exactly match wall-clock time. |
| @availabilityTimeOffset | Optional, default is INF.  If the @availabilityTimeOffset attribute is present for a Representation in the Segment Information or the **BaseURL** element, then the parameter availabilityTimeOffset is determined as the sum of all values of @availabilityTimeOffset on all levels that are processed in determining the URL for the corresponding segment. Then the adjusted segment availability start time is determined by subtracting the value of availabilityTimeOffset from the Segment availability start time. This adjusted segment availability start time provides a time instant in wall-clock time at which a Segment becomes an available Segment. |

These attributes are specific to multi-segment only with *Simple addressing* (no child **SegmentTemplate**) 

| Attribute Name | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| @duration      | Required, specifies the constant approximate duration.  All Segments within this Representation element have the same duration unless it is the last Segment within the Period, which can be significantly shorter. |
| @startNumber   | Optional, default value is 1.   This is used for the Template-based URL's as the $Number$ template value.  The $*Number*$ identifier is replaced by (*k*−1) + (@startNumber−1), where k is the position in the **Representation**.  This is ignored if $Time$ is used in the template. |

These attributes are specific to *Indexed addressing* 

| Attribute Name | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| @indexRange    | Required, specifies the byte range that contains the *Segment index* |
| @startNumber   | Optional, default value is 1.   This is used for the Template-based URL's as the $Number$ template value.  The $*Number*$ identifier is replaced by (*k*−1) + (@startNumber−1), where k is the position in the **Representation**.  This is ignored if $Time$ is used in the template. |

The **SegmentBase** child elements are as follows:



### SegmentTimeline

The SegmentTimeline element is used in *Explicit addressing* it contains a minimum of one child *S* (Segment) element.  In the ISO 23009-1 standard section *5.3.9.6 Segment timeline* describes every detail and possible encoding of this mode, this section describes the subset that is possible while staying conformant to DASH-IF IOP 4.3 and what the Xperi-supported players can actually play.

The attributes of the **S** element are described below, anything from the ISO IEC 23009-1 *Section 5.3.9.2.2 Segment Base* not in the table is not supported by the Xperi players:


| Attribute Name             | Description                                                  |
| -------------------------- | ------------------------------------------------------------ |
| @t                  | Determines the MPD Timeline of the segment and the `$Time$` identifier in the URL template.  Simply the *value* minus the *@presentationTimeOffset* (scaled by any *@timescale*) plus *Period@start* equals the MPD Timeline time of the segment start.  This value shall be identical to the earliest_presentation_time in the **sidx** box in the segment fMP4.<br /><br />The attribute is optional, if it is not set it is assumed to be zero for the first **S** element, and for the subsequent **S** elements, the value shall be assumed to be the sum of the previous **S** element's earliest presentation time and contiguous duration, [i.e. `previous S@t + @d * (@r + 1)`]<br /><br />While it is possible to have time discontinuities If the value of the attribute is greater than what is expressed by the previous **S** attribute doing so could lead to stalls at the worst case and certainly at least a bad user experience as content drop outs will cause playback perturbations.  See the section on GAPs and Track Availability for a better way done just as simply with **Period** splits. |
| @d | Required, specifies the duration of the segment or sequence of segments in @timescale units. |
| @r | Default is 0 (no repeat), otherwise the number of **repeated** copies of this S element (eg r=1 implies two elements).   A negative value indicates that the duration indicated in *@d* attribute repeats until the start of the next **S** element, the end of the Period, or until the next MPD update.  Note this is [supported by ExoPlayer](https://github.com/google/ExoPlayer/issues/1787), but likely not widely supported. |



## Streaming Features

### Media Content Changes

#### Background

The DASH **Period** is the essential ingredient to combine multiple disparate sets of media into a complete presentation.  Multiple **Period**s enable:

- splicing content for ad insertion
- adding or removing **AdaptationSets** (to enable dropping PID, e.g. adding or removing secondary audio)
- Gaps in media from one or more **Representations**
- Re-synchronization (discontinuities in Sample time) 

The DASH-IOP and the ISO 230009 section *5.3.2.4 Content offering with multiple Periods* define a complete set (but rather complex) set of rules for the metadata to indicate how **Period** transitions are to be treated by the player.

1. [Period connectivity](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#timing-connectivity) &mdash; contents are compatible across the related **AdptationSet**s
2. [Period continuity](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#timing-continuity) &mdash; periods are connected with no timeline discontinuity

The reality is ***none*** of our supported open source players (ExoPlayer, Dash.js, or Shaka-Player) looks for the `urn:mpeg:dash:period-continuity` in the `EssentialProperty`

For ExoPlayer each upstream change is evaluated for each renderer type (Video, Audio, Text, etc.) if the stream format changes require a CODEC reset, if not the change is completely seamless.

To enable seemless transiton for the Media Source (MSE, Media Source Extensions) based players (Dash.js, Shaka, etc.) they must avoid the [abort()](https://www.w3.org/TR/media-source-2/#methods-0) call, most recent versions (Shaka after [3.1.1](https://github.com/shaka-project/shaka-player/blob/main/CHANGELOG.md#311-2021-06-17),  Dash.js after [V3](https://github.com/Dash-Industry-Forum/dash.js/wiki/Migration-3.0)).

#### Modifying Periods

DASH *Early Termination Period*'s  are the key enabling technology for signaling content changes to the players.  The allowed mechanisms are described in the IOP section [5.2.9.5. MPD updates](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#timing-mpd-updates).  Specifically the *Period@duration* may be modified, to shorten the period or turn a "live" (unlimited duration) Period into a fixed duration period.   Note the *Period@start* cannot change, implicitly or explicitly.   

To early terminate the live period, for *Explcit addressin*g, do the following steps:

1. Let `availabilityEndTime` be the end time as calculated in [With Explicit Addressing](#with-explicit-addressing) - `@presentationTimeOffset / @timescale` (to adjust to period time) 
2. Set the last period's `@duration` to `availabilityEndTime` - `Period@start`,  this ends the current period at the time of it's next segment
3. Add a new `Period`, that has no `@duration`, this opens the new live period.  For the **AdaptationSets** that continue, their `@presentationTimeOffset` should be set to the `S@t` of the first segment + any overlap if that segment is repeated from the previous (Early Terminated) **Period**



### Key Rotation

#### Overview

For DASH Widevine (other DRM systems are not described here) data in the MPD and the CMAF-encoded media define the parameters for content protection.  In the MPD, the **ContentProtection** elements signal encrypted content in the manifest at the **AdaptationSet** level.   The encryption boxes (`tenc`, `schm`, `schi`, ...) provide the metadata for CMAF Common Encryption, which includes.

##### MPD (manifest)

The most recent [DASH-IOP Guidelines for Content Protection and Security](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#CPS-mpd) requires (*SHALL*) a **ContentProtection** element that signals the content is encrypted with Common Encryption (CENC), specifies the `default_KID` and the protection schema (encryption type, e.g. `cbcs`).   For ExoPlayer the `default_KID` MUST BE in UUID format, as described in the `urn:mpeg:cenc:2013` XML schema in the CENC ISO Standard.   

In addition, DASH-IOP Guidelines recommend (*SHOULD*) that one or more **ContentProtection** elements be supplied that provide the [DRM system configuration](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#drm-system-configuration), for Widevine this must be an `@schemaIdUri` of `urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed`.   The Widevine **ContentProtection** must include a child `<cenc:pssh>` element with text that is the Base64 encoding of the Widevine pssh.  The IOP requires this value to match the `pssh` box contents in the CMAF initialization segment, and notes that the `pssh` in the init segment is deprecated.   Both Shaka player (see [Shaka issue 1107](https://github.com/shaka-project/shaka-player/issues/1107)) and ExoPlayer use the MPD `pssh` if present and ignore the initialization segment (`moov/pssh`) 

##### CMAF Data

The data required for Widevine is specified in the CMAF ISO Standard ISO 23001-7 and outlined in the DASH-IOP section [8.1. Content protection data in CMAF containers](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#CPS-cmaf-structure).  Key information is the:

1. ***Protection System Specific Data (PSSH)*** &mdash; The DRM system is identified by the `SystemID` (should be  `edef8ba9-79d6-4ace-a3c8-27dcd51d21ed` for Widevine), the `pssh.data` contains the actual Widevine license request data (mainly a list of content key_id's).  Note this is ignored by the players if `pssh` data is present in the MPD, the IOP states `pssh` in the initialization segment is "deprecated"
2. ***Sample Encryption Info*** &mdash; This data must be specified at the track level (`moov/trak/...`) and may be overridden by group of samples or by each sample, to allow different keys or a mix of clear and protected content.   The specific data is:
   * *encryption method*  &mdash; this is the 4 char code  ([DASH recommends](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#protection-scheme)  `cenc` or `cbcs` ), this is specified only at the track level (in the `moov/trak/.../sinf/schm` box)
   * *KID* &mdash; identifies the key in the current DRM session for decrypting the sample[s], the default from the track level (`moov/trak/.../sinf/tenc` values) and may be overridden at the sample group level for a CMAF fragment (with the `moof/traf/sgpd` box values)
   * *encryption parameters* &mdash; Specific to the encryption method parameters, such as initialization vectors, clear and protected ranges, as well as pattern ranges.  These are described in the CMAF ISO standard and are beyond the scope of this document.

This metadata in the MPD is sufficient for the players to issue a license request, using the DRM scheme, to securely obtain the encryption key[s] required to decrypt the media for the indicated content (KID).   Presenting encryption information in the MPD allows the player to fetch licenses needed to decrypt in parallel with loading the CMAF content, reducing the chances of stalls for content playback.  The CMAF data contains the information required to decrypt the content.

#### Rotation Options

Widevine offers many options for the "rotation" of keys.  They include:

1. Manifest based signaling, or "Periodic re-authorization"
2. In-band key rotation
3. In-band key hierarchy

One of the most confusing parts of reading the ISO standards and DASH IOP guidelines is they overuse the word "key".  To be clear there are:

* ***Content Key*** (Default_KID in the `pssh`)
* ***Cryptographic Key Id*** (KID[s] in the track (`tenc`) or segment (`sgpd`)) &mdash; these are used by OEM Crypto to look up a specific AES Decryption Key in the session's secure key-box
* ***Cryptographic keys*** &mdash; the **actual** key required to decrypt the samples

In the most simple case, the Content Key (Default_KID) identifies a single Cryptographic Key. 

##### Manifest Based

To "rotate" entitlement (that is force a new license request) the MPD must contain multiple **Periods**, each period boundary the **ContentProtection** element is changed (specifically the Base64 encoded `pssh`).  This is called out in DASH IOP Security Guidelines [Section 12 Period re-authorization](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#CPS-PeriodReauth). 

Manifest based is the most secure way (in fact the only way) to enforce rights validation for different content, however, changing the [content key](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#content-key) alone does not increase the cryptographic security of the content.  

This brand of "rotation" is expensive as a new license request must be generated by OEMCrypto and sent to the Widevine proxy, this can stall playback if the response is not timely.   ExoPlayer caches multiple open OEMCrypt sessions to reduce the need to re-issue the requests

##### In-band (internal key rotation)

The in-band methods all work similarly, allowing a single content key to "unlock" a section of content that is encrypted with *multiple* disparate encryption keys. request multiple decryption keys in a single license request (`pssh`) and update the KID that is in the `moof/traf/sgpd` boxes (so per-segment or segment group)

Either a key hierarchy method (described in IOP section [13. Controlling access rights with a key hierarchy](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html#CPS-KeyHierarchy)) or updating the `default_KID` described in the [DASH-IOP V6](https://dashif.org/docs/IOP-Guidelines/DASH-IF-IOP-Part6-v5.0.0.pdf) section *9.3 In-band key rotation signalling* [sic]. 

### Trick-Play 

#### Overview

Xperi trick-play uses [I-Frame](https://streaminglearningcenter.com/articles/everything-you-ever-wanted-to-know-about-idr-frames-but-were-afraid-to-ask.html) (aka IDR frames) only playback to present a fast playback experience with MPEG video.  There are two modes of playback:

1. Scrub Mode &mdash; allows fine-grained frame level stepping with user input (scrub bar, track pad, remote keys, etc) 
2. Scan Mode &mdash; automatically plays selected frames in high speed forward or reverse at a moderate frame rate (3 - 6 FPS).  Speeds are from 15 to 60x playback

The ExoPlayer implementation uses seek to nearest sync point to implement Scrub Mode, to facilitate this:

1. The IDR frames should be at an interval of at least 0.5 FPS 
2. Each IDR frame should be placed in alone in a segment,  including the next 2 P/B frames improves operation on Broadcom based SoC's (this is what Apple's mediafilesegmenter does)

The player internally adapts the frame rate, using a proprietary algorithm, to adapt to higher playback rates in scan mode. 

The IDR Frames must:

- Be derived from or indexed to matching IDR's in one of the regular playback streams
- Match up with IDR's in the non-trickmode streams (to enable fast seamless switching in and out of trick-play mode)
- May or may not be encrypted

#### Trick-play DASH Encoding

Trick-play requires an `AdapationSet` containing the `Representation` elements that contain the segmented i-Frame only stream.  This `AdaptationSet` is marked with an `EssentialProperty` with the DASH schema for trickmode Functionality, see [DASH-IF Functionality](https://dashif.org/identifiers/functionality/)   The [DASH-IOP Section 6.3 Trick mode](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#trickmode) outlines how this is done.  The sections below present examples and describe the Xperi requirements to support ExoPlayer trick-play.

##### Static Mode

An example from Shaka Packager that uses Index addressing (aka SegmentBase).  Index addressing only works in a *static* presentation or fixed duration **Period**. 

```xml
    <AdaptationSet id="1" contentType="video" width="640" height="360" maxFrameRate="30000/30030" par="16:9">
      <EssentialProperty schemeIdUri="http://dashif.org/guidelines/trickmode" value="0"/>
      <Representation id="1" bandwidth="211545" codecs="avc1.64001e" mimeType="video/mp4" sar="1:1" frameRate="30000/30030" maxPlayoutRate="30" codingDependency="false">
        <BaseURL>bear-640x360-video-trick_play_factor_1.mp4</BaseURL>
        <SegmentBase indexRange="870-937" timescale="30000">
          <Initialization range="0-869"/>
        </SegmentBase>
      </Representation>
      <Representation id="2" bandwidth="211545" codecs="avc1.64001e" mimeType="video/mp4" sar="1:1" frameRate="30000/60060" maxPlayoutRate="60" codingDependency="false">
        <BaseURL>bear-640x360-video-trick_play_factor_2.mp4</BaseURL>
        <SegmentBase indexRange="870-925" timescale="30000">
          <Initialization range="0-869"/>
        </SegmentBase>
      </Representation>
    </AdaptationSet>
```



##### Dynamic Mode

For live playlists we recommend using either Explicit addressing or Simple addressing and generating segments at the highest frame rate (0.5 FPS, or the GOP interval) directly from the samples in an existing regular video representation's Chunk (see the CMAF Encoding section below).  From this based set of segments it is quite simple to produce lower frame rate multiples simply by modifying the **SegmentTimeline** (Explicit addressing) or the *SegmentTemplate@duraiton* (Simple addressing).

The example below shows how this can be done with Explicit addressing, assuming 60000/1001 FPS (drop frame) base frame rate with a 120 frame target GOP interval.  The example produces three trickmode **Representations** with *Representation@frameRate* values that are suitable for playout speeds from 0 (scrub mode) up to 60x.  

```xml
<AdaptationSet id="2" contentType="video" par="16:9" maxWidth="1280" maxHeight="720" maxFrameRate="500/1001" segmentAlignment="true">
    <EssentialProperty schemeIdUri="http://dashif.org/guidelines/trickmode" value="1"/>
    <Representation width="1280" height="720" sar="16:9" frameRate="500/1001" maxPlayoutRate="15" mimeType="video/mp4" codecs="avc1.640020" startWithSAP="1" id="trick_1" bandwidth="184862">
        <SegmentTemplate presentationTimeOffset="1686681376382366" timescale="1000000" media="720p_4_5Mbs-1_trick_T$Time$~D0.cmfv" initialization="720p_4_5Mbs-1_1671819467_tinit.cmfv">
            <SegmentTimeline>
                <S t="1686681376382366" d="2002000" r="679"/>
            </SegmentTimeline>
        </SegmentTemplate>
    </Representation>
    <Representation width="1280" height="720" sar="16:9" frameRate="250/1001" maxPlayoutRate="30" mimeType="video/mp4" codecs="avc1.640020" startWithSAP="1" id="720p_4_trick_2" bandwidth="92431">
        <SegmentTemplate presentationTimeOffset="1686681376382366" timescale="1000000" media="720p_4_5Mbs-1_trick_T$Time$~D0.cmfv" initialization="720p_4_5Mbs-1_1671819467_tinit.cmfv">
            <SegmentTimeline>
                <S t="1686681376382366" d="4004000" r="339"/>
            </SegmentTimeline>
        </SegmentTemplate>
    </Representation>
    <Representation width="1280" height="720" sar="16:9" frameRate="125/1001" maxPlayoutRate="60" mimeType="video/mp4" codecs="avc1.640020" startWithSAP="1" id="720p_4_trick_3" bandwidth="46215">
        <SegmentTemplate presentationTimeOffset="1686681376382366" timescale="1000000" media="720p_4_5Mbs-1_trick_T$Time$~D0.cmfv" initialization="720p_4_5Mbs-1_1671819467_tinit.cmfv">
            <SegmentTimeline>
                <S t="1686681376382366" d="6006000" r="225"/>
            </SegmentTimeline>
        </SegmentTemplate>
    </Representation>
</AdaptationSet>
```

Things to note from the example above:

1. The same segments are used for all 3 **Representations**, only the duration changes
2. Segments are generated from video **AdaptationSet** with id=2 (not shown)

Note when the players  compute the window size explicitly (from **SegmentTimeline**) the ***min*** size timeline is used, so if iFrames are not generated in realtime either a seperate period or idefinate repeating segment (S@r = -1) must be used.

##### Common Requirements

The Xperi Player requires:

1. Multiple **Representation**'s with frame rates from 0.5 FPS down to 0.1 FPS (this allows scan mode trick-play up to 60x)
2. The `frameRate` attribute, it is used to determine a practical max playback rate
3. At least one **Representation** with the highest possible frame rate (like Apple's HLS recommendation, this should be at least 0.5 FPS)
4. Each **Representation** must include a `bandwidth` attribute that gives the actual bandwidth required for playing the iFrames at normal speed (should be significantly less than the Source Variant)

and recommends:

1. Multiple lower frame rate **Representation** to enable higher speed playback
2.  The **Representation**  used to generate the trick mode **Representation**[s] should be:

   - Be selectable by the video resolution
   - Match the resolution and codec of one of the regular video variants (the Source Variant)
   - be chosen from a resolution that balances providing adequate display resolution for a pleasant user experience.

##### CMAF Encoding

The media for a trickmode segment must be packaged as a CMAF Chunk, for example:

```shell
[moof] size=8+108
  [mfhd] size=12+4
    sequence number = 568
  [traf] size=8+84
    [tfhd] size=12+16, flags=2002a
      track ID = 1
      sample description index = 1
      default sample duration = 2001900
      default sample flags = 0
    [tfdt] size=12+8, version=1
      base media decode time = 1683247471947932
    [trun] size=12+24, flags=a01
      sample count = 1
      data offset = 
      entries:
        (       0) sample_size = 69754, sample_composition_time_offset = 16688
[mdat] size=8+69754
```

As stated before, packing only a single sample in each Chunk allows for:

1. The most accurate seek targeting for Scan mode processing
2. Reusing the same trickmode segments to produce lower frame rates by simply modifying the timeline to skip segments.

If multiple SAP samples are placed in the same chunk (as Shaka-packager does) then multiple CMAF packaging is required to implement different frame-rate **Rendition**s

A `sidx` box is not required for Explicit addressed trickmode segments.

Note, it should be possible to extract this structure, even on the fly, from an existing GOP chunked regular representation by using the `sidx` to locate offsets then trucating the `mdat` and `trun`.   The steps are:

1. Open the segment (file or stream) and read up through the `sidx` box (should be first or second box)
2. Use the `sidx.referenced_size` to determine the offset of each chunk.
3. Read the chunk, just up to the `moof` end
4. The `trun` box in the `moof` gives the offset of the first sample (which must be an iFrame)
5. Read just the bytes of the `mdat` that comprise this first sample
6. Modify the `trun` box to remove all but the first sample and update the `trun.data_offset` ,  `trun.sampleCount` and it's box size
7. write the updated `moof` and truncated `mdat` to the trickplay segment

##### Xperi Specific Notes

When encoding trick-play **AdaptationSet** based on the The [DASH-IOP Section 6.3 Trick mode](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#trickmode) section, we require the following.

###### Use frameRate not maxPlayoutRate

The spec states `@maxPlayoutRate` should be used to differentiate multiple **Representations**:

> - signal the playout capabilities with the attribute `@maxPlayoutRate` for each [representation](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#representation) in order to indicate the accelerated playout that is enabled by the signaled codec profile and level.

Note that ExoPlayer does not parse this value at all.  The `@frameRate` and `@bandwidth` attribues are parsed so these should be specified as shown in the example to facilitate choosing the proper **Representation** for a specific fast playback speed.

###### Identify Source AdaptationSet

Also, match the trick-mode **AdaptationSet** to the regular **AdaptationSet**, the spec says:

> annotate each [adaptation set](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#adaptation-set) with an [essential property descriptor](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#essential-property-descriptor) or [supplemental property descriptor](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#supplemental-property-descriptor) with URL `http://dashif.org/guidelines/trickmode` and the `@value` the value of `@id` attribute of the [adaptation set](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#adaptation-set) with which these trick mode [representations](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#representation) are associated.

It also goes on to indicate the *@value* attribute may be a list of *@id* values, that is parsed by ExoPlayer properly but on the first one is used.  We recommend only associating one trick-mode **AdaptationSet** to one regular **AdaptationSet**.

###### Only use SAP Samples

ExoPlayer assumes and expects that samples in the trick-mode segments contain **only** SAP samples, the spec says:

> - If the [representation](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#representation) is encoded without any coding dependency on the elementary stream level, i.e. each sample is a SAP type 1, then you SHOULD set the `Representation@codingDependency` attribute to `false`.

The `@codingDependency` attribute is not parsed by ExoPlayer or any other player we are aware of, it is simply assumed there is no dependency (samples are SAP)

###### Time align and match duration

The spec states:

> The trick mode [representations](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#representation) must be time-aligned with the [representations](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#representation) in the referenced [adaptation set](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html#adaptation-set).

We recommend the 

**Match Representation durations for live** &mdash; when determining the most recent availability window time ExoPlayer performs a max() across all **Representation**s, so trick-mode end must not be earlier than any non-trick mode.



## Clarifcations From The Referenced DASH Specs

### MPD Attributes

1. **Use @suggestedPresentationDelay** &mdash; If not specified ExoPlayer will default to 5 seconds.  ExoPlayer sets the live-offset target based on this value, Shaka player uses this to directly set the starting live position.  Xperi recommends setting this value and not setting *@minBufferTime* (as the player's treatment of this is conflicting)

### Segment Addressing

1. **Explicit addressing for live** &mdash; using Explicit addressing modes with *dynamic* MPD avoids potential 404's on segment references if the origin is not able to transcode within a segment duration.   The only cost is a slightly larger MPD size and delay finding the newest live segment.
2. **Code SegmentTimeline at AdaptationSet Level** &mdash; note that they should all be the same for each **Representation**, as required by IOP section [9.1. Sample timeline](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html#timing-sampletimeline).  Also, the players determine window 
3. **Code compact SegmentTimelines** &mdash; all of the Xperi-supported players support these features reducing MPD size:
     1. **Use segment repeat** &mdash; use `@d` attribute to repeat same duration segments
     2. **Eliminate redundant values** &mdash; unless there is a Sample timeline gap (not recommended!), `@t` attribute should only be on first segment
     3. **Use inheritance** &mdash; values in the `SegmentBaseType` are inherited from the **Period** all the way to the **Representation** tht uses them.  Move common values up the inheritance tree to reduce duplication

## References

This document was prepared from the understanding the implementation in the acutal players that Xperi uses that support DASH.    Everything is cross referenced to the following standards and clarifcations documents

- ***The ISO standard***  ([ISO / IEC 23009 Spec](https://www.iso.org/standard/79329.html))  &mdash; Every possible construct in DASH is described in detail in this document.
- ***The DASH Industry Forum Guidlines*** &mdash; The DASH-IF Interoperability Points (IOP), the discussions in this document will mostly reference the last completed version, [DASH IF IOP V4.3](https://dashif-documents.azurewebsites.net/DASH-IF-IOP/master/DASH-IF-IOP.html).   This is an easier to read description of DASH.
- ***The DASH-IF Restricted Timing Model*** ([DASH-IOP Timing Model](https://dashif-documents.azurewebsites.net/Guidelines-TimingModel/master/Guidelines-TimingModel.html) ) &mdash; The restricted timing model describes how to deal with content gaps in a way that is broadly supported by players.
- ***Common Encryption*** (ISO/IEC 23001-7:2016) &mdash; Describes format of CMAF segments for various encryption methods
- ***DASH-IF implementation guidelines: content protection and security*** ([DASH-IF 24, July 2020](https://dashif-documents.azurewebsites.net/Guidelines-Security/master/Guidelines-Security.html)) &mdash; The DASH-IOP Guildelines for content protection, the head of the git commit tree goes into more detail on DRM structures in the manifest and CMAF media.
- ***DASH-IF IOP Part 6 V5*** ([DASH-IF IOP Part 6](https://dashif.org/docs/IOP-Guidelines/DASH-IF-IOP-Part6-v5.0.0.pdf)) &mdash; Explains signaling of DRM schema and content encryption in the MPD

